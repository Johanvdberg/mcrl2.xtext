/*
 * generated by Xtext 2.11.0.beta2
 */
package tuks.mcrl2.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tuks.mcrl2.dsl.mclrDsl.ActDecl;
import tuks.mcrl2.dsl.mclrDsl.ActIdSet;
import tuks.mcrl2.dsl.mclrDsl.ActList;
import tuks.mcrl2.dsl.mclrDsl.ActSpec;
import tuks.mcrl2.dsl.mclrDsl.ActionName;
import tuks.mcrl2.dsl.mclrDsl.ActionNameList;
import tuks.mcrl2.dsl.mclrDsl.Assignment;
import tuks.mcrl2.dsl.mclrDsl.AssignmentList;
import tuks.mcrl2.dsl.mclrDsl.BagEnumElt;
import tuks.mcrl2.dsl.mclrDsl.BagEnumEltList;
import tuks.mcrl2.dsl.mclrDsl.ConsSpec;
import tuks.mcrl2.dsl.mclrDsl.ConstrDecl;
import tuks.mcrl2.dsl.mclrDsl.ConstrDeclList;
import tuks.mcrl2.dsl.mclrDsl.ConstrName;
import tuks.mcrl2.dsl.mclrDsl.DataExpr;
import tuks.mcrl2.dsl.mclrDsl.DataExpr1;
import tuks.mcrl2.dsl.mclrDsl.DataExpr2;
import tuks.mcrl2.dsl.mclrDsl.DataExprList;
import tuks.mcrl2.dsl.mclrDsl.DataExprTerm;
import tuks.mcrl2.dsl.mclrDsl.DataExprUnit;
import tuks.mcrl2.dsl.mclrDsl.DataExprUnitTerm;
import tuks.mcrl2.dsl.mclrDsl.DataName;
import tuks.mcrl2.dsl.mclrDsl.EqnDecl;
import tuks.mcrl2.dsl.mclrDsl.EqnSpec;
import tuks.mcrl2.dsl.mclrDsl.GlobVarSpec;
import tuks.mcrl2.dsl.mclrDsl.Init;
import tuks.mcrl2.dsl.mclrDsl.MapSpec;
import tuks.mcrl2.dsl.mclrDsl.MclrDslPackage;
import tuks.mcrl2.dsl.mclrDsl.Model;
import tuks.mcrl2.dsl.mclrDsl.MultActId;
import tuks.mcrl2.dsl.mclrDsl.MultActIdList;
import tuks.mcrl2.dsl.mclrDsl.MultActIdSet;
import tuks.mcrl2.dsl.mclrDsl.ProcDecl;
import tuks.mcrl2.dsl.mclrDsl.ProcExpr;
import tuks.mcrl2.dsl.mclrDsl.ProcExprTerm;
import tuks.mcrl2.dsl.mclrDsl.ProcName;
import tuks.mcrl2.dsl.mclrDsl.ProcSpec;
import tuks.mcrl2.dsl.mclrDsl.ProjDecl;
import tuks.mcrl2.dsl.mclrDsl.ProjDeclList;
import tuks.mcrl2.dsl.mclrDsl.ProjName;
import tuks.mcrl2.dsl.mclrDsl.SortDecl;
import tuks.mcrl2.dsl.mclrDsl.SortExpr;
import tuks.mcrl2.dsl.mclrDsl.SortExprTerm;
import tuks.mcrl2.dsl.mclrDsl.SortIdList;
import tuks.mcrl2.dsl.mclrDsl.SortIdsDecl;
import tuks.mcrl2.dsl.mclrDsl.SortName;
import tuks.mcrl2.dsl.mclrDsl.SortSpec;
import tuks.mcrl2.dsl.mclrDsl.VarIdList;
import tuks.mcrl2.dsl.mclrDsl.VarName;
import tuks.mcrl2.dsl.mclrDsl.VarSpec;
import tuks.mcrl2.dsl.mclrDsl.VarsDecl;
import tuks.mcrl2.dsl.mclrDsl.VarsDeclList;
import tuks.mcrl2.dsl.mclrDsl.mCRL2SpecElt;
import tuks.mcrl2.dsl.services.MclrDslGrammarAccess;

@SuppressWarnings("all")
public class MclrDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MclrDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MclrDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MclrDslPackage.ACT_DECL:
				sequence_ActDecl(context, (ActDecl) semanticObject); 
				return; 
			case MclrDslPackage.ACT_ID_SET:
				sequence_ActIdSet(context, (ActIdSet) semanticObject); 
				return; 
			case MclrDslPackage.ACT_LIST:
				sequence_ActList(context, (ActList) semanticObject); 
				return; 
			case MclrDslPackage.ACT_SPEC:
				sequence_ActSpec(context, (ActSpec) semanticObject); 
				return; 
			case MclrDslPackage.ACTION:
				sequence_Action(context, (tuks.mcrl2.dsl.mclrDsl.Action) semanticObject); 
				return; 
			case MclrDslPackage.ACTION_NAME:
				sequence_ActionName(context, (ActionName) semanticObject); 
				return; 
			case MclrDslPackage.ACTION_NAME_LIST:
				sequence_ActionNameList(context, (ActionNameList) semanticObject); 
				return; 
			case MclrDslPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MclrDslPackage.ASSIGNMENT_LIST:
				sequence_AssignmentList(context, (AssignmentList) semanticObject); 
				return; 
			case MclrDslPackage.BAG_ENUM_ELT:
				sequence_BagEnumElt(context, (BagEnumElt) semanticObject); 
				return; 
			case MclrDslPackage.BAG_ENUM_ELT_LIST:
				sequence_BagEnumEltList(context, (BagEnumEltList) semanticObject); 
				return; 
			case MclrDslPackage.CONS_SPEC:
				sequence_ConsSpec(context, (ConsSpec) semanticObject); 
				return; 
			case MclrDslPackage.CONSTR_DECL:
				sequence_ConstrDecl(context, (ConstrDecl) semanticObject); 
				return; 
			case MclrDslPackage.CONSTR_DECL_LIST:
				sequence_ConstrDeclList(context, (ConstrDeclList) semanticObject); 
				return; 
			case MclrDslPackage.CONSTR_NAME:
				sequence_ConstrName(context, (ConstrName) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR:
				sequence_DataExpr(context, (DataExpr) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR1:
				sequence_DataExpr1(context, (DataExpr1) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR2:
				sequence_DataExpr2(context, (DataExpr2) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR_LIST:
				sequence_DataExprList(context, (DataExprList) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR_TERM:
				sequence_DataExprTerm(context, (DataExprTerm) semanticObject); 
				return; 
			case MclrDslPackage.DATA_EXPR_UNIT:
				if (rule == grammarAccess.getDataExprUnitRule()) {
					sequence_DataExprUnit(context, (DataExprUnit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcExprTermRule()) {
					sequence_DataExprUnit_ProcExprTerm(context, (DataExprUnit) semanticObject); 
					return; 
				}
				else break;
			case MclrDslPackage.DATA_EXPR_UNIT_TERM:
				sequence_DataExprUnitTerm(context, (DataExprUnitTerm) semanticObject); 
				return; 
			case MclrDslPackage.DATA_NAME:
				sequence_DataName(context, (DataName) semanticObject); 
				return; 
			case MclrDslPackage.EQN_DECL:
				sequence_EqnDecl(context, (EqnDecl) semanticObject); 
				return; 
			case MclrDslPackage.EQN_SPEC:
				sequence_EqnSpec(context, (EqnSpec) semanticObject); 
				return; 
			case MclrDslPackage.GLOB_VAR_SPEC:
				sequence_GlobVarSpec(context, (GlobVarSpec) semanticObject); 
				return; 
			case MclrDslPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case MclrDslPackage.MAP_SPEC:
				sequence_MapSpec(context, (MapSpec) semanticObject); 
				return; 
			case MclrDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MclrDslPackage.MULT_ACT_ID:
				sequence_MultActId(context, (MultActId) semanticObject); 
				return; 
			case MclrDslPackage.MULT_ACT_ID_LIST:
				sequence_MultActIdList(context, (MultActIdList) semanticObject); 
				return; 
			case MclrDslPackage.MULT_ACT_ID_SET:
				sequence_MultActIdSet(context, (MultActIdSet) semanticObject); 
				return; 
			case MclrDslPackage.PROC_DECL:
				sequence_ProcDecl(context, (ProcDecl) semanticObject); 
				return; 
			case MclrDslPackage.PROC_EXPR:
				sequence_ProcExpr(context, (ProcExpr) semanticObject); 
				return; 
			case MclrDslPackage.PROC_EXPR_TERM:
				sequence_ProcExprTerm(context, (ProcExprTerm) semanticObject); 
				return; 
			case MclrDslPackage.PROC_NAME:
				sequence_ProcName(context, (ProcName) semanticObject); 
				return; 
			case MclrDslPackage.PROC_SPEC:
				sequence_ProcSpec(context, (ProcSpec) semanticObject); 
				return; 
			case MclrDslPackage.PROJ_DECL:
				sequence_ProjDecl(context, (ProjDecl) semanticObject); 
				return; 
			case MclrDslPackage.PROJ_DECL_LIST:
				sequence_ProjDeclList(context, (ProjDeclList) semanticObject); 
				return; 
			case MclrDslPackage.PROJ_NAME:
				sequence_ProjName(context, (ProjName) semanticObject); 
				return; 
			case MclrDslPackage.SORT_DECL:
				sequence_SortDecl(context, (SortDecl) semanticObject); 
				return; 
			case MclrDslPackage.SORT_EXPR:
				sequence_SortExpr(context, (SortExpr) semanticObject); 
				return; 
			case MclrDslPackage.SORT_EXPR_TERM:
				sequence_SortExprTerm(context, (SortExprTerm) semanticObject); 
				return; 
			case MclrDslPackage.SORT_ID_LIST:
				sequence_SortIdList(context, (SortIdList) semanticObject); 
				return; 
			case MclrDslPackage.SORT_IDS_DECL:
				sequence_SortIdsDecl(context, (SortIdsDecl) semanticObject); 
				return; 
			case MclrDslPackage.SORT_NAME:
				sequence_SortName(context, (SortName) semanticObject); 
				return; 
			case MclrDslPackage.SORT_SPEC:
				sequence_SortSpec(context, (SortSpec) semanticObject); 
				return; 
			case MclrDslPackage.VAR_ID_LIST:
				sequence_VarIdList(context, (VarIdList) semanticObject); 
				return; 
			case MclrDslPackage.VAR_NAME:
				sequence_VarName(context, (VarName) semanticObject); 
				return; 
			case MclrDslPackage.VAR_SPEC:
				sequence_VarSpec(context, (VarSpec) semanticObject); 
				return; 
			case MclrDslPackage.VARS_DECL:
				sequence_VarsDecl(context, (VarsDecl) semanticObject); 
				return; 
			case MclrDslPackage.VARS_DECL_LIST:
				if (rule == grammarAccess.getProcExprTermRule()) {
					sequence_ProcExprTerm_VarsDeclList(context, (VarsDeclList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarsDeclListRule()) {
					sequence_VarsDeclList(context, (VarsDeclList) semanticObject); 
					return; 
				}
				else break;
			case MclrDslPackage.MCRL2_SPEC_ELT:
				sequence_mCRL2SpecElt(context, (mCRL2SpecElt) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActDecl returns ActDecl
	 *
	 * Constraint:
	 *     (id=ActList sort=SortExpr?)
	 */
	protected void sequence_ActDecl(ISerializationContext context, ActDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActIdSet returns ActIdSet
	 *
	 * Constraint:
	 *     ids=ActionNameList
	 */
	protected void sequence_ActIdSet(ISerializationContext context, ActIdSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.ACT_ID_SET__IDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.ACT_ID_SET__IDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActIdSetAccess().getIdsActionNameListParserRuleCall_1_0(), semanticObject.getIds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ActList returns ActList
	 *
	 * Constraint:
	 *     (id_list+=ActionName id_list+=ActionName*)
	 */
	protected void sequence_ActList(ISerializationContext context, ActList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActSpec returns ActSpec
	 *
	 * Constraint:
	 *     act_list+=ActDecl+
	 */
	protected void sequence_ActSpec(ISerializationContext context, ActSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionNameList returns ActionNameList
	 *
	 * Constraint:
	 *     (id_list+=[ActionName|ID] id_list+=[ActionName|ID]*)
	 */
	protected void sequence_ActionNameList(ISerializationContext context, ActionNameList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionName returns ActionName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ActionName(ISerializationContext context, ActionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.ACTION_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.ACTION_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (id=[ActionName|ID] exp=DataExprList?)
	 */
	protected void sequence_Action(ISerializationContext context, tuks.mcrl2.dsl.mclrDsl.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentList returns AssignmentList
	 *
	 * Constraint:
	 *     (ass+=Assignment ass+=Assignment*)
	 */
	protected void sequence_AssignmentList(ISerializationContext context, AssignmentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (id=VarName data_exp=DataExpr)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.ASSIGNMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.ASSIGNMENT__ID));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.ASSIGNMENT__DATA_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.ASSIGNMENT__DATA_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getIdVarNameParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getAssignmentAccess().getData_expDataExprParserRuleCall_2_0(), semanticObject.getData_exp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BagEnumEltList returns BagEnumEltList
	 *
	 * Constraint:
	 *     (bag_list+=BagEnumElt bag_list+=BagEnumElt*)
	 */
	protected void sequence_BagEnumEltList(ISerializationContext context, BagEnumEltList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BagEnumElt returns BagEnumElt
	 *
	 * Constraint:
	 *     (left=DataExpr right=DataExpr)
	 */
	protected void sequence_BagEnumElt(ISerializationContext context, BagEnumElt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.BAG_ENUM_ELT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.BAG_ENUM_ELT__LEFT));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.BAG_ENUM_ELT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.BAG_ENUM_ELT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagEnumEltAccess().getLeftDataExprParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBagEnumEltAccess().getRightDataExprParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConsSpec returns ConsSpec
	 *
	 * Constraint:
	 *     ids+=ConstrName+
	 */
	protected void sequence_ConsSpec(ISerializationContext context, ConsSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstrDeclList returns ConstrDeclList
	 *
	 * Constraint:
	 *     (decl+=ConstrDecl decl+=ConstrDecl*)
	 */
	protected void sequence_ConstrDeclList(ISerializationContext context, ConstrDeclList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstrDecl returns ConstrDecl
	 *
	 * Constraint:
	 *     (id=ConstrName proj=ProjDeclList? right_id=ID?)
	 */
	protected void sequence_ConstrDecl(ISerializationContext context, ConstrDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstrName returns ConstrName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ConstrName(ISerializationContext context, ConstrName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.CONSTR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.CONSTR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstrNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataExpr1 returns DataExpr1
	 *
	 * Constraint:
	 *     (left=DataExpr2 right=DataExpr)
	 */
	protected void sequence_DataExpr1(ISerializationContext context, DataExpr1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.DATA_EXPR1__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.DATA_EXPR1__LEFT));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.DATA_EXPR1__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.DATA_EXPR1__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataExpr1Access().getLeftDataExpr2ParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDataExpr1Access().getRightDataExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataExpr2 returns DataExpr2
	 *
	 * Constraint:
	 *     (left=DataExprTerm right=DataExpr)
	 */
	protected void sequence_DataExpr2(ISerializationContext context, DataExpr2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.DATA_EXPR2__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.DATA_EXPR2__LEFT));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.DATA_EXPR2__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.DATA_EXPR2__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataExpr2Access().getLeftDataExprTermParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDataExpr2Access().getRightDataExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataExprList returns DataExprList
	 *
	 * Constraint:
	 *     (data_exp+=DataExpr data_exp+=DataExpr*)
	 */
	protected void sequence_DataExprList(ISerializationContext context, DataExprList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataExprTerm returns DataExprTerm
	 *
	 * Constraint:
	 *     (
	 *         var_id=[VarName|ID] | 
	 *         num=INT | 
	 *         is_true?='true' | 
	 *         is_false?='false' | 
	 *         (is_sqaure_bracket?='[' data_list=DataExprList?) | 
	 *         (is_curly_bracket?='{' (is_colon?=':' | bag=BagEnumEltList | data_exp_list=DataExprList | (var_decl=VarsDecl data_exp=DataExpr))?) | 
	 *         (is_round_bracket?='(' data_exp=DataExpr) | 
	 *         data_exp=DataExpr | 
	 *         data_exp=DataExpr | 
	 *         data_exp=DataExpr | 
	 *         ((is_forall?='forall' | is_exist?='exists' | is_lambda?='lambda') var_list=VarsDeclList data_exp=DataExpr)
	 *     )
	 */
	protected void sequence_DataExprTerm(ISerializationContext context, DataExprTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataExprUnitTerm returns DataExprUnitTerm
	 *
	 * Constraint:
	 *     (
	 *         id=DataName | 
	 *         number=INT | 
	 *         is_true?='true' | 
	 *         is_false?='false' | 
	 *         exp=DataExpr | 
	 *         ((is_exp?='!' | is_minus?='-' | is_sharp?='#') unit=DataExprUnit)
	 *     )
	 */
	protected void sequence_DataExprUnitTerm(ISerializationContext context, DataExprUnitTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataExprUnit returns DataExprUnit
	 *
	 * Constraint:
	 *     (lower=DataExprUnitTerm data=DataExprList?)
	 */
	protected void sequence_DataExprUnit(ISerializationContext context, DataExprUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcExprTerm returns DataExprUnit
	 *
	 * Constraint:
	 *     (lower=DataExprUnitTerm data=DataExprList? proc_exp=ProcExpr proc_exp_other=ProcExpr?)
	 */
	protected void sequence_DataExprUnit_ProcExprTerm(ISerializationContext context, DataExprUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataExpr returns DataExpr
	 *
	 * Constraint:
	 *     (left=DataExpr1 ((right_1=DataExpr right_2=DataExpr) | right=DataExprList))
	 */
	protected void sequence_DataExpr(ISerializationContext context, DataExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataName returns DataName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DataName(ISerializationContext context, DataName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.DATA_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.DATA_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EqnDecl returns EqnDecl
	 *
	 * Constraint:
	 *     (cond=DataExpr? left=DataExpr right=DataExpr)
	 */
	protected void sequence_EqnDecl(ISerializationContext context, EqnDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqnSpec returns EqnSpec
	 *
	 * Constraint:
	 *     (spec=VarSpec? eqn+=EqnDecl+)
	 */
	protected void sequence_EqnSpec(ISerializationContext context, EqnSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobVarSpec returns GlobVarSpec
	 *
	 * Constraint:
	 *     vars_list+=VarsDeclList+
	 */
	protected void sequence_GlobVarSpec(ISerializationContext context, GlobVarSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Init returns Init
	 *
	 * Constraint:
	 *     proc=ProcExpr
	 */
	protected void sequence_Init(ISerializationContext context, Init semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.INIT__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.INIT__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitAccess().getProcProcExprParserRuleCall_1_0(), semanticObject.getProc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MapSpec returns MapSpec
	 *
	 * Constraint:
	 *     ids+=SortIdsDecl+
	 */
	protected void sequence_MapSpec(ISerializationContext context, MapSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (left+=mCRL2SpecElt* init=Init right+=mCRL2SpecElt*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultActIdList returns MultActIdList
	 *
	 * Constraint:
	 *     (acts+=MultActId acts+=MultActId*)
	 */
	protected void sequence_MultActIdList(ISerializationContext context, MultActIdList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultActIdSet returns MultActIdSet
	 *
	 * Constraint:
	 *     (data=MultActIdList | is_empty?=WS)
	 */
	protected void sequence_MultActIdSet(ISerializationContext context, MultActIdSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultActId returns MultActId
	 *
	 * Constraint:
	 *     (ids+=[ActionName|ID] ids+=[ActionName|ID]*)
	 */
	protected void sequence_MultActId(ISerializationContext context, MultActId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcDecl returns ProcDecl
	 *
	 * Constraint:
	 *     (id=ProcName variables=VarsDeclList? right=ProcExpr)
	 */
	protected void sequence_ProcDecl(ISerializationContext context, ProcDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcExprTerm returns ProcExprTerm
	 *
	 * Constraint:
	 *     (
	 *         action=Action | 
	 *         (proc_id=[ProcName|ID] ass=AssignmentList?) | 
	 *         (map_id=[SortName|ID] ass=AssignmentList?) | 
	 *         is_delta?='delta' | 
	 *         is_tau?='tau' | 
	 *         (is_block?='block' act_set=ActIdSet proc_exp=ProcExpr) | 
	 *         (is_allow?='allow' multi_set=MultActIdSet proc_exp=ProcExpr) | 
	 *         (is_hide?='hide' act_set=ActIdSet proc_exp=ProcExpr) | 
	 *         (is_grp?='(' proc_exp=ProcExpr) | 
	 *         (is_sum?='sum' variables=VarsDeclList proc_exp=ProcExpr)
	 *     )
	 */
	protected void sequence_ProcExprTerm(ISerializationContext context, ProcExprTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcExprTerm returns VarsDeclList
	 *
	 * Constraint:
	 *     (varialbes+=VarsDecl varialbes+=VarsDecl* data=DataExpr proc_exp=ProcExpr)
	 */
	protected void sequence_ProcExprTerm_VarsDeclList(ISerializationContext context, VarsDeclList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcExpr returns ProcExpr
	 *
	 * Constraint:
	 *     (
	 *         left=ProcExprTerm 
	 *         (
	 *             (
	 *                 (
	 *                     is_plus?='+' | 
	 *                     is_par?='||' | 
	 *                     is_par_right?='||_' | 
	 *                     is_left_shist?='<<' | 
	 *                     is_point?='.' | 
	 *                     is_or?='|'
	 *                 ) 
	 *                 right=ProcExpr
	 *             ) | 
	 *             (is_at?='@' unit_right=DataExprUnit)
	 *         )
	 *     )
	 */
	protected void sequence_ProcExpr(ISerializationContext context, ProcExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcName returns ProcName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProcName(ISerializationContext context, ProcName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.PROC_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.PROC_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcSpec returns ProcSpec
	 *
	 * Constraint:
	 *     procs+=ProcDecl+
	 */
	protected void sequence_ProcSpec(ISerializationContext context, ProcSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProjDeclList returns ProjDeclList
	 *
	 * Constraint:
	 *     (proj+=ProjDecl prof+=ProjDecl*)
	 */
	protected void sequence_ProjDeclList(ISerializationContext context, ProjDeclList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProjDecl returns ProjDecl
	 *
	 * Constraint:
	 *     (id=ProjName? sort=SortExpr)
	 */
	protected void sequence_ProjDecl(ISerializationContext context, ProjDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProjName returns ProjName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProjName(ISerializationContext context, ProjName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.PROJ_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.PROJ_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortDecl returns SortDecl
	 *
	 * Constraint:
	 *     (id=SortName sort=SortExpr)
	 */
	protected void sequence_SortDecl(ISerializationContext context, SortDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_DECL__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_DECL__ID));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_DECL__SORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_DECL__SORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortDeclAccess().getIdSortNameParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSortDeclAccess().getSortSortExprParserRuleCall_2_0(), semanticObject.getSort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortExprTerm returns SortExprTerm
	 *
	 * Constraint:
	 *     (
	 *         is_bool?='Bool' | 
	 *         is_pos?='Pos' | 
	 *         is_nat?='Nat' | 
	 *         is_int?='Int' | 
	 *         is_real?='Real' | 
	 *         ((is_list?='List' | set?='Set' | bag?='Bag' | fset?='FSet' | fbag?='FBag') exp=SortExpr) | 
	 *         id=[SortName|ID] | 
	 *         exp=SortExpr | 
	 *         const=ConstrDeclList
	 *     )
	 */
	protected void sequence_SortExprTerm(ISerializationContext context, SortExprTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SortExpr returns SortExpr
	 *
	 * Constraint:
	 *     (left=SortExprTerm right=SortExpr)
	 */
	protected void sequence_SortExpr(ISerializationContext context, SortExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortExprAccess().getLeftSortExprTermParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSortExprAccess().getRightSortExprParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortIdList returns SortIdList
	 *
	 * Constraint:
	 *     (id_list+=SortName id_list+=SortName*)
	 */
	protected void sequence_SortIdList(ISerializationContext context, SortIdList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SortIdsDecl returns SortIdsDecl
	 *
	 * Constraint:
	 *     (id=SortIdList sort=SortExpr)
	 */
	protected void sequence_SortIdsDecl(ISerializationContext context, SortIdsDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_IDS_DECL__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_IDS_DECL__ID));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_IDS_DECL__SORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_IDS_DECL__SORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortIdsDeclAccess().getIdSortIdListParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSortIdsDeclAccess().getSortSortExprParserRuleCall_2_0(), semanticObject.getSort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortName returns SortName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SortName(ISerializationContext context, SortName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.SORT_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.SORT_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortSpec returns SortSpec
	 *
	 * Constraint:
	 *     sorts+=SortDecl+
	 */
	protected void sequence_SortSpec(ISerializationContext context, SortSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarIdList returns VarIdList
	 *
	 * Constraint:
	 *     (id_list+=VarName id_list+=VarName*)
	 */
	protected void sequence_VarIdList(ISerializationContext context, VarIdList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarName returns VarName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VarName(ISerializationContext context, VarName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.VAR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.VAR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarSpec returns VarSpec
	 *
	 * Constraint:
	 *     list+=VarsDeclList+
	 */
	protected void sequence_VarSpec(ISerializationContext context, VarSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarsDeclList returns VarsDeclList
	 *
	 * Constraint:
	 *     (varialbes+=VarsDecl varialbes+=VarsDecl*)
	 */
	protected void sequence_VarsDeclList(ISerializationContext context, VarsDeclList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarsDecl returns VarsDecl
	 *
	 * Constraint:
	 *     (id=VarIdList sort=SortExpr)
	 */
	protected void sequence_VarsDecl(ISerializationContext context, VarsDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.VARS_DECL__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.VARS_DECL__ID));
			if (transientValues.isValueTransient(semanticObject, MclrDslPackage.Literals.VARS_DECL__SORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MclrDslPackage.Literals.VARS_DECL__SORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarsDeclAccess().getIdVarIdListParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getVarsDeclAccess().getSortSortExprParserRuleCall_2_0(), semanticObject.getSort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     mCRL2SpecElt returns mCRL2SpecElt
	 *
	 * Constraint:
	 *     (
	 *         sort=SortSpec | 
	 *         const=ConsSpec | 
	 *         map=MapSpec | 
	 *         eqn=EqnSpec | 
	 *         blobal=GlobVarSpec | 
	 *         act=ActSpec | 
	 *         proc=ProcSpec
	 *     )
	 */
	protected void sequence_mCRL2SpecElt(ISerializationContext context, mCRL2SpecElt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
